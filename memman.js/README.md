# Memman.js

### LEARNING https://rollupjs.org/ 

1. npm install rollup --global

2. npm run build

#### compilar 
"build": "rollup -c"




#### 
Enfoque basado en componentes (React, Vue): Permite a los desarrolladores crear componentes reutilizables y modulares que pueden ser fácilmente ensamblados para construir aplicaciones web más grandes y complejas.

Inyección de dependencias (Angular): Facilita la gestión de dependencias entre componentes y servicios, lo que facilita la prueba, la reutilización y el mantenimiento del código.

Enrutamiento (Angular, React-Router, Vue-Router): Proporciona una solución de enrutamiento integrada y fácil de usar que facilita la navegación entre componentes y la gestión del historial del navegador.

Manejo de estados (Redux, Vuex): Ofrece una solución escalable y predecible para administrar el estado de la aplicación y compartir datos entre componentes.

Optimización del rendimiento (Qwik): Incluye técnicas de optimización de rendimiento, como carga diferida y pre-renderización, para mejorar la velocidad de carga y la interacción del usuario.

Interoperabilidad con Web Components: Asegura que los componentes creados con el compilador sean compatibles con los estándares de Web Components, lo que facilita su uso en diferentes entornos y proyectos.

memmanRef: Un hook similar al ref de Vue3, utilizado para obtener una referencia a un elemento de la interfaz de usuario.

memmanReactive: Un hook similar a reactive de Vue3, utilizado para hacer que un objeto sea reactivo y actualizar la vista automáticamente cuando cambia.

memmanWatchEffect: Un hook similar a watchEffect de Vue3, utilizado para reaccionar a un cambio en una dependencia y actualizar la vista automáticamente.

memmanComputed: Un hook similar a computed de Vue3, utilizado para calcular un valor a partir de una o varias dependencias.

memmanUseState: Un hook similar a useState de React, utilizado para crear una variable de estado en un componente funcional.

memmanUseEffect: Un hook similar a useEffect de React, utilizado para ejecutar una función de efecto secundario después de cada renderizado.

memmanUseContext: Un hook similar a useContext de React, utilizado para obtener un objeto de contexto de React en un componente funcional.

memmanUseReducer: Un hook similar a useReducer de React, utilizado para manejar un estado complejo en un componente funcional.

memmanUse: Un hook similar a use de Mintlang, utilizado para crear un hook personalizado en un componente funcional.

memmanOnMount: Un hook similar a onMount de Mintlang, utilizado para ejecutar una función después de que el componente se haya montado en la página.

memmanOnUpdate: Un hook similar a onUpdate de Mintlang, utilizado para ejecutar una función después de que el componente se haya actualizado.

memmanOnDestroy: Un hook similar a onDestroy de Mintlang, utilizado para ejecutar una función antes de que el componente se elimine de la página.

memmanNgOnInit: Un hook similar a ngOnInit de Angular, utilizado para ejecutar una función después de que el componente se haya inicializado.

memmanNgOnChanges: Un hook similar a ngOnChanges de Angular, utilizado para ejecutar una función después de que se hayan producido cambios en las propiedades de entrada de un componente.

memmanNgOnDestroy: Un hook similar a ngOnDestroy de Angular, utilizado para ejecutar una función antes de que el componente se elimine de la página.

memmanNgAfterViewInit: Un hook similar a ngAfterViewInit de Angular, utilizado para ejecutar una función después de que se hayan inicializado las vistas de un componente.


memmanUseEffect: Un hook similar a useEffect de Preact, utilizado para ejecutar una función de efecto secundario después de cada renderizado.

memmanUseRef: Un hook similar a useRef de Preact, utilizado para obtener una referencia a un elemento de la interfaz de usuario.

memmanUseLayoutEffect: Un hook similar a useLayoutEffect de Preact, utilizado para ejecutar una función de efecto secundario sincrónica después de cada renderizado.

memmanCreateSignal: Un hook similar a createSignal de Solid, utilizado para crear una señal reactiva que se actualiza automáticamente cuando cambia su valor.

memmanCreateEffect: Un hook similar a createEffect de Solid, utilizado para ejecutar una función de efecto secundario cuando cambia su valor de entrada.

memmanCreateMemo: Un hook similar a createMemo de Solid, utilizado para crear una memoria que almacena el resultado de una función hasta que sus dependencias cambien.

memmanOnCleanup: Un hook similar a onCleanup de Solid, utilizado para ejecutar una función antes de que se elimine un componente.
